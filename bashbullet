#!/bin/bash

# Bashbullet	: a pushbullet systray notification daemon for linux. also a simple client to receive, mirror and send pushes
# Author	: Boteium - https://github.com/Boteium

# running in the background parameter
export DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
[[ ! -z "$1" && "$1" == '-scr' ]] && screen -S bashbullet-session -dm $DIR/bashbullet && exit

# display warning message
if ! ps -o stat= -p $$ |grep + >/dev/null;then
notify-send Warning "Bashbullet is running in the background
Make sure to start it by screen/systemd/upstart or it will not work
e.g. screen -S bashbullet-session -dm ./bashbullet"
fi

# check dependencies
for i in yad wscat jshon notify-send;do
	if ! [ `whereis -b $i|cut -d ':' -f2` ];then
		echo command $i not found, please install it and try again && exit 0
	fi
done

# Read Configration file
[ ! -x ~/.bashbullet/received/archived ] && mkdir -p ~/.bashbullet/received/archived
if [ -f ~/.bashbullet/config ];then
	source ~/.bashbullet/config
	[ ! -f ~/.bashbullet/.last_timestamp ] && date +%s > ~/.bashbullet/.last_timestamp
	LASTTIME=`cat ~/.bashbullet/.last_timestamp`
	[ -z $allow_file_shorten ] && allow_file_shorten=false
	targets=0
	while(( 1 ));do
		eval test -z \"\${target_filter_$targets}\" && break
		let targets++
	done
	if [ -f /usr/share/bashbullet/pushbullet.svg ];then
		export SRC='/usr/share/bashbullet'
	else
		export SRC="$DIR"
	fi
else
	echo please put your API_KEY=\"your_key\" in ~/.bashbullet/config
	echo see /usr/share/bashbullet/config_example for configuration guide
	exit 0
fi

# initialize yad systray icon
export PIPE=`mktemp -u --tmpdir ${0##*/}.XXXXXXXX`
mkfifo $PIPE

# attach a file descriptor to the file
exec 3<> $PIPE

# add handler to manage process shutdown
on_exit() {
    echo "quit" >&3
    rm -f $PIPE
}
trap on_exit EXIT

# simple client for sending pushes to phone
new_push(){
	IFS='
'
	source ~/.bashbullet/config
        DEVS_RAW=`curl -s --header "Authorization: Bearer $API_KEY" https://api.pushbullet.com/v2/devices`
        DEVS=(`jshon -e devices <<< "$DEVS_RAW"|grep \"nickname\"|cut -d \" -f4`)
        IDEN=(`jshon -e devices <<< "$DEVS_RAW"|grep \"iden\"|cut -d \" -f4`)
        PU(){
		if curl -s "https://api.pushbullet.com/v2/pushes" \
                 -u "$API_KEY": -d device_iden="$1" -d type="$2" -d title="$3" \
                 --data-urlencode body="`printf $4`" -X POST |\
		grep 'active":true' >/dev/null;then notify-send -t 1000 "pushed";fi
		# use printf to translate \n to newline
        }
        decode_identity(){
                for(( i=0 ; i<${#IDEN[@]} ; i++ ));do
                        if [ "$1" == "${DEVS[$i]}" ];then
                                echo "${IDEN[$i]}"
                                return 0;
                        fi
                done
        }
	# generate yad readable list
        DEVICES=`for i in ${DEVS[@]};do echo -n \;$i;done|cut -c 2-`

        IFS='|'
	# generate yad dialogue
        NOTE=(`yad --mouse --form --height=300 --title "Bashbullet :: new push" \
              --field="Device":CB "${DEVICES}" \
              --field="Title" "" --field="Note":TXT "" --item-separator=';' \
              --button="Discard:1" --button="Push it:2"`)
	# push to phone
        if [ $? == 2 ];then
                [ -z ${NOTE[1]} ] && NOTE[1]="untitled"
                PU `decode_identity "${NOTE[0]}"`  note "${NOTE[1]}" "${NOTE[2]}"
        fi
}
export -f new_push

# add handler for tray icon left click
on_click() {
	YADKEY=${RANDOM}

	# aggregate all messages and sort by received time
	if [ "`ls ${HOME}/.bashbullet/received/*_* 2>/dev/null`" ];then
		( tac ${HOME}/.bashbullet/received/*_*|sed -e 's/^  / _-|/g' -e 's/^FROM/  --- From/g'|\
		tr -d '\n'|sed 's/ _-|/\n/g' ;printf '\n')|tac > ${HOME}/.bashbullet/.disp_tmp
	else
		echo "No new messages" > ${HOME}/.bashbullet/.disp_tmp
	fi
	if [ "`ls ${HOME}/.bashbullet/received/archived/`" ];then
		( tac ${HOME}/.bashbullet/received/archived/*_*|sed -e 's/^  / _-|/g' -e 's/^FROM/  --- From/g'|\
                tr -d '\n'|sed 's/ _-|/\n/g' ;printf '\n')|sed -e '/^$/d'|tac > ${HOME}/.bashbullet/.arch_tmp
		tac ${HOME}/.bashbullet/received/archived/OldArchive.txt >> ${HOME}/.bashbullet/.arch_tmp 2>/dev/null
	else
		echo "No archived messages" > ${HOME}/.bashbullet/.arch_tmp
	fi

	# generate yad tab
	yad --plug=$YADKEY --tabnum=1 --text-info --filename=${HOME}/.bashbullet/.disp_tmp &
	yad --plug=$YADKEY --tabnum=2 --text-info --filename=${HOME}/.bashbullet/.arch_tmp &

	yad --mouse --notebook --key=$YADKEY --width=600 --height=400 --title "Bashbullet Inbox" \
		--window-icon="${SRC}/pushbullet.svg" --tab="New Messages" --tab="Archived Messages" --title "Bashbullet Inbox" \
		--button "Close:1" --button "Mark all as read:2" --button "Archive all:3" --button "New push:4"
	case  $? in
		2)
		echo icon:"${SRC}/pushbullet.svg" > ${PIPE} ;;
		3)
		rm ${HOME}/.bashbullet/received/archived/*_* 2>/dev/null
		tac ${HOME}/.bashbullet/.arch_tmp  > ${HOME}/.bashbullet/received/archived/OldArchive.txt
		mv ${HOME}/.bashbullet/received/*_* ${HOME}/.bashbullet/received/archived/
		echo icon:"${SRC}/pushbullet.svg" > ${PIPE} ;;
		4)
		new_push
		;;
	esac
	find ~/.bashbullet/received/*dismissed* -type f -cmin +5 -delete 2>/dev/null &
}
export -f on_click

# create yad notification icon
yad --notification --title bashbullet --listen \
    --image="$SRC/pushbullet.svg" \
    --text="click to display new message" \
    --command="bash -c \"on_click\"" <&3 &

IFS='
'
[ -z $DISPLAY ] && DISPLAY=:0

# Pushbullet api url
CL(){   curl -s --header "Authorization: Bearer $API_KEY" https://api.pushbullet.com/v2/${1} ;}

# Convert device id to name
decode_name(){
	for(( i=0 ; i<${#DEVS[@]} ; i++ ));do
		if [ $1 == ${IDEN[$i]} ];then
			echo "${DEVS[$i]}"
			return 0;
		fi
	done
}

# extract push from json
j_push(){ jshon -e pushes -e $@ <<< "$RAWMSG" ;}

mirrored(){
	# use sed instead of jshon to parse
	FROM=$(decode_name `echo $line|sed -e 's/.*source_device_iden":"//g' -e 's/",".*//g'`)
	TITLE=`echo $line|sed -e 's/.*title":"//g' -e 's/",".*//g'`
	BODY=`echo $line|sed -e 's/.*body":"//g' -e 's/",".*//g'`
	APP=`echo $line|sed -e 's/.*application_name":"//g' -e 's/",".*//g'`
	ICO=`echo  $line|sed -e 's/.*icon":"//g' -e 's/"}}.*//g'`
	ICON=`mktemp -u --tmpdir ${0##*/}.ico.XXXXXXXX`
	echo -e $ICO |tr -d '\n' |tr -d '\' 2>/dev/null|base64 -d > $ICON
 	if [ ! -z $ICONFORMAT ];then
 		eval convert "$ICON" $ICONSIZE "$ICON${ICONFORMAT}"
 	fi
 	notify-send -t 5000 -i ${ICON}${ICONFORMAT} "$FROM $APP :: $TITLE" "`printf "$BODY"`"
	[ ! -z DING_MIRROR ] && eval $DING_MIRROR &
        rm ${ICON}*
}
save(){
	( eval echo "\ $FROM \>\> $TO"
	  echo  \ \ ${TYPE}:: $URL $MSG ) > ~/.bashbullet/received/${TIME}_`echo $TO|tr -d ' '`_${TYPE}
	echo icon:mail-unread > $PIPE
	[ ! -z $DING ] && eval $DING
}

# notify-send and save
disp_save(){
	TYPE=`j_push $ENTRY -e type|tr -d \"`
	if [ -z `j_push $ENTRY -e source_device_iden` ];then
		FROM=`j_push $ENTRY -e sender_name |tr -d \"`
	else
		FROM=$(decode_name `j_push $ENTRY -e source_device_iden |tr -d \"`)
	fi
	MSG=$(eval echo `j_push $ENTRY | egrep 'title|body'|cut -d : -f2-`)
	URL=$(eval echo `j_push $ENTRY | egrep '_url|\"url'|cut -d : -f2-`)
	if [[  $allow_file_shorten == "true" || $TYPE != file ]];then
		[ ! -z "$SHORT_URL" ] && URL=`eval echo "$URL"|eval $SHORT_URL`
	fi

	if eval test -z \"\$custom_command_$j\" ;then
		[[ ! -z $xdg_open && ! -z "$URL" ]] && xdg-open "$URL"
		notify-send -t 7000 "${TYPE} : ${FROM} >> ${TO}" "$URL $MSG"
		save
	else

	if eval test -z \"\${skip_$j}\" ;then
			save
		else
			touch ~/.bashbullet/received/${TIME}_`echo $TO|tr -d ' '`_dismissed
		fi
		eval eval \$custom_command_$j &
	fi
}

# handle device filter
device_filter(){
	TO=`jshon -e pushes -e $ENTRY -e target_device_iden <<< "$RAWMSG" 2>/dev/null|tr -d \"`
	if [ -z $TO ];then
		TO="all"
	else
		TO=`decode_name $TO`
	fi

	# handle receiver device filter (if set in config)
	if [[  $targets == 0 || "$TO" == all ]];then
		j=NAN; disp_save
	else
		for((j=0; j<$targets ;j++));do
			eval test \"$TO\" == \"\${target_filter_$j}\" && disp_save
		done
	fi
}

# Retrieve pushes after "$1" time
get_msg(){
	RAWMSG=`CL pushes?modified_after=$1`

	CNT=`jshon -e pushes <<< "$RAWMSG"|grep \"created\"|wc -l`
	for(( ENTRY=0 ; ENTRY < $CNT ; ENTRY++ ));do
		# check if push is "active" and "not dismissed"
		# will disable dismissed checking (controled by $2 parameter) if it is retriving
		# pushes from the past, and enable checking if it is retriving new pushes
		if [ `j_push $ENTRY -e active` == "true" ];then
			if [[ "$2" == 'dont_care' || `j_push $ENTRY -e dismissed` == 'false' ]];then
				TIME=`j_push $ENTRY -e created`
				if [ ! -f ~/.bashbullet/received/${TIME}* ];then
					device_filter
				fi
			fi
		fi
	done
}

## Monitoring websocket for push event
tickle_detect(){
	while true ; do
	    if read -r line; then
		if grep push <<< $line >/dev/null 2>/dev/null;then
			if grep mirror <<< $line >/dev/null 2>/dev/null;then
				mirrored
			else
				get_msg `date --date="-15sec" +%s` check_dismissed
			fi
			date +%s > ~/.bashbullet/.last_timestamp
		fi
	    fi
	done
}

DEVS_RAW=`CL devices`
DEVS=(`jshon -e devices <<< "$DEVS_RAW"|grep \"nickname\"|cut -d \" -f4`)
IDEN=(`jshon -e devices <<< "$DEVS_RAW"|grep \"iden\"|cut -d \" -f4`)

if [ "`ls ${HOME}/.bashbullet/received/*_* 2>/dev/null`" ];then
	echo icon:mail-unread > $PIPE
fi

get_msg $LASTTIME dont_care
date +%s > ~/.bashbullet/.last_timestamp

# wscat | remove color code | extract json
wscat -c wss://websocket.pushbullet.com/subscribe/$API_KEY|tickle_detect
